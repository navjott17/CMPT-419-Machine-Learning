# -*- coding: utf-8 -*-
"""CMPT726_419_A2_Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MBABqkDjTAOp0j06Q9GAOBfhkH7tM07r

## Before you start

We recommend running this notebook on Google Colab to avoid having to install dependencies.

Note:

*   You can use any functions provided in the numpy, but not the functions in scipy.
*   You should use *numpy.linalg.solve()* to invert a matrix for more numerical stable results rather than *numpy.linalg.inv()*. Refer to [link](http://gregorygundersen.com/blog/2020/12/09/matrix-inversion/) for more details.
* Try to avoid for-loops. Refer to [link](https://www.learndatasci.com/tutorials/applied-introduction-to-numpy-python-tutorial/) for more details.

## Load packages
"""

import numpy as np
from scipy import stats

"""## Part c: Computing optimal $\vec{\gamma}$

Implement the function below, which defines the input data matrix $\mathbf{A}$ (variable A) and the vector of desired outputs $\vec{y}$ (variable y). Calculate the optimal $\vec{\gamma}$ (variable gamma_star). All the variables should be the type of np.float64.
"""

def part_2c(l, odd_indexed_sum):
  """
  l: Number of possible outcomes.
  odd_indexed_sum: Sum of the probability masses of Q at odd-indexed outcomes
  return: Input data matrix A, desired outputs y, and optimal parameters gamma_star
  """
  # TODO: Assign the variables below appropriately

  c1 = np.ones(10)
  c2 = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
  A = np.column_stack([c1, c2])

  y = np.array([[1.0], [0.8]])

  A_t = np.transpose(A)
  I = np.identity(2)
  A_At = np.matmul(A_t, A)
  inv = np.linalg.inv(A_At + I)
  inv = np.matmul(inv, A_t)
  inv = inv*y
  gamma_star = inv

  return A, y, gamma_star

l = 10
odd_indexed_sum = 0.8

A, y, gamma_star = part_2c(l, odd_indexed_sum)

# Do not modify the lines below
assert(isinstance(A, np.ndarray))
assert(A.dtype == np.float64)
assert(isinstance(y, np.ndarray))
assert(y.dtype == np.float64)
assert(isinstance(gamma_star, np.ndarray))
assert(gamma_star.dtype == np.float64)

print("A:\n{}\ny:\n{}\n".format(A, y))
print("gamma_star:\n{}".format(gamma_star))
print("Prediction:\n{}".format(A.dot(gamma_star)))
print("Loss:\n{}".format(np.linalg.norm(y - A.dot(gamma_star))))

"""## Part e: Computing optimal $\mathrm{vec}(\mathbb{\Gamma})$

Implement the function below, which defines the data matrix $\mathbf{A}$ (variable A) and label vector $\vec{y}$ (variable y). Calculate the optimal $\mathrm{vec}(\mathbb{\Gamma})$ (variable Gamma_star) using the formula derived in part *d*.

Note: The $\vec{p}$, $\vec{q}$, $\{u_i\}_{i=1}^{l}$ and $\{v_j\}_{i=1}^{l}$ are given as the variables p, q, U and V.
"""

def part_2e(l, p, q, U, V):
  """
  l: Number of possible outcomes.
  p: Probability mass function of P.
  q: Probability mass function of Q.
  U: All possible outcomes of P. 
  V: All possible outcomes of Q. 
  return: Input data matrix A, desired outputs y, and optimal parameters Gamma_star
  """
  # TODO: Assign the variables below appropriately

  A = None

  y = None

  Gamma_star = None

  return A, y, Gamma_star

# Do not modify the lines below

U = np.linspace(0, 9, num=10)
V = np.linspace(5, 14, num=10)

# Poisson distributions
p = stats.poisson.pmf(U, mu=4)
q = stats.poisson.pmf(V, mu=10)

# Normalize distributions
p = (p / np.sum(p)).astype(np.float64)
q = (q / np.sum(q)).astype(np.float64)

l = U.shape[0]  # l = 10

A, y, Gamma_star = part_2e(l, p, q, U, V)

assert(isinstance(A, np.ndarray))
assert(A.dtype == np.float64)
assert(isinstance(y, np.ndarray))
assert(y.dtype == np.float64)
assert(isinstance(Gamma_star, np.ndarray))
assert(Gamma_star.dtype == np.float64)

print("A:\n{}\ny:\n{}\n".format(A, y))
print("Gamma_star:\n{}".format(Gamma_star))
print("Prediction:\n{}".format(A.dot(Gamma_star)))
print("Loss:\n{}".format(np.linalg.norm(y - A.dot(Gamma_star))))

"""## Part g: Computing optimal $\mathrm{vec}(\mathbb{\Gamma})$

Write code below that defines the data matrix $\mathbf{A}$ (variable A), label vector $\vec{y}$ (variable y) and distance vector $\vec{\lambda}$ (variable la). Calculate the optimal $\mathrm{vec}(\mathbb{\Gamma})$ (variable Gamma_star) with those variables base on part *f*.

Note:

*   The $\vec{p}$, $\vec{q}$, $\{u_i\}_{i=1}^{l}$ and $\{v_j\}_{i=1}^{l}$ are given as the variables p, q, U and V.
*   The distance between $u_i$ and $v_j$ is defined in the given function *distance_between()*, for example distance between $u_i = 2$ and $v_j = 5$ is $\vert 2 - 5 \vert$.
"""

def part_2g(l, p, q, U, V, D):
  """
  l: Number of possible outcomes.
  p: Probability mass function of P.
  q: Probability mass function of Q.
  U: All possible outcomes of P. 
  V: All possible outcomes of Q. 
  D: Matrix of distances between U and V. 
  return: Input data matrix A, desired outputs y, distance vector la and optimal parameters Gamma_star
  """
  # TODO: Assign to the variables below appropriately

  A = None

  y = None

  la = None

  Gamma_star = None

  return A, y, la, Gamma_star

# Do not modify the lines below

def distance_between(U, V):
    return np.abs(U[:,np.newaxis] - V[np.newaxis,:])

U = np.linspace(0, 9, num=10)
V = np.linspace(5, 14, num=10)

# Poisson distributions
p = stats.poisson.pmf(U, mu=4)
q = stats.poisson.pmf(V, mu=10)

# Normalize distributions
p = (p / np.sum(p)).astype(np.float64)
q = (q / np.sum(q)).astype(np.float64)

l = U.shape[0]  # l = 10

D = distance_between(U, V)

A, y, la, Gamma_star = part_2g(l, p, q, U, V, D)

assert(isinstance(A, np.ndarray))
assert(A.dtype == np.float64)
assert(isinstance(y, np.ndarray))
assert(y.dtype == np.float64)
assert(isinstance(la, np.ndarray))
assert(la.dtype == np.float64)
assert(isinstance(Gamma_star, np.ndarray))
assert(Gamma_star.dtype == np.float64)

print("A:\n{}\ny:\n{}\nlambda:\n{}".format(A, y, la.transpose(1, 0)))
print("Gamma_star:\n{}".format(Gamma_star))
print("Prediction:\n{}".format(A.dot(Gamma_star)))
print("Loss:\n{}".format(np.linalg.norm(y - A.dot(Gamma_star))))